---
title: "How Tool Calling Works in Large Language Models"
description: "Learn how LLMs use external tools and functions to perform real-world tasks beyond text generation."
date: "2025-11-21"
author: "Ayush Sharma"
tags: ["AI", "LLM", "Tool Calling", "OpenRouter", "Vercel AI SDK"]
readingTime: "12 min read"
featured: true
imageUrl: "https://1kf0b6y5pd.ufs.sh/f/whL3sWlbNOAP4M3YEMVEKBr0gueU6fJkSAaYjWMON8X2HPdV"
---

Have you ever wondered how ChatGPT checks weather forecasts, sends emails, or searches the web for current information? The answer lies in tool calling, also known as function calling. This capability has become one of the most transformative features in modern AI, bridging the gap between what language models understand and what they can actually do.

In this guide, we'll explore how tool calling works under the hood, why it matters for real-world applications, and how developers are using it to build powerful AI agents.

## What is Tool Calling?

Without tool calling, a large language model is remarkably intelligent but fundamentally constrained. Despite its impressive reasoning capabilities, it can only work with knowledge acquired during training. This means:

- No access to current weather conditions or stock prices
- Cannot send emails or create calendar events
- Unable to query databases for real-time information
- Cannot perform actions in external systems
- No knowledge of events after its training cutoff date

Tool calling fundamentally changes this dynamic. It enables AI models to interact with external functions and APIs, transforming them from sophisticated text generators into capable agents that can take meaningful actions.

Think of it this way: without tools, an LLM is like a brilliant advisor who can only provide recommendations. With tools, it becomes an executive assistant capable of executing tasks on your behalf.

## The Evolution of Tool Calling

OpenAI introduced function calling in June 2023 with GPT-3.5 Turbo and GPT-4. Since then, it has evolved into a standard feature across the AI landscape:

**OpenAI** supports it across GPT-4, GPT-4 Turbo, GPT-4o series, and the latest GPT-5 models.

**Anthropic** has implemented it in Claude 3 series and Claude 4 series, including Sonnet 4.5, Opus 4.1, and Haiku 4.5.

**Google** offers it in Gemini Pro, Gemini 2.0 Flash, and Gemini Ultra.

**Open-source models** are catching up fast, with support available via platforms like Ollama, Together AI, and Replicate.

The API has become increasingly standardized across providers, making it straightforward to switch between models while maintaining consistent tool-calling interfaces. As of November 2025, Anthropic introduced structured outputs in public beta, providing guaranteed schema conformance for Claude's responses. This is a major step toward more reliable tool interactions.

## How Tool Calling Works: The Complete Flow

Understanding the tool calling process is essential for grasping how modern AI applications work. Let's break down each step.

![Tool Calling Flowchart](https://1kf0b6y5pd.ufs.sh/f/whL3sWlbNOAPySL2WroEDeUo3XJ0zRAdWNGj9hns5b6fBcZC)

### Step 1: Define Your Tools

First, you define what tools are available to the AI. Each tool needs three components:

1. **Name**: A clear identifier like `get_weather`
2. **Description**: What it does and when to use it
3. **Parameters**: What inputs it needs

Here's what a simple weather tool looks like:

```typescript
{
  name: "get_weather",
  description: "Get current weather for a location",
  parameters: {
    location: "string",  // e.g., 'Tokyo, Japan'
    unit: "celsius" or "fahrenheit"
  }
}
```

The description is absolutely critical. The AI uses it to decide when to invoke the tool. A vague description like "gets data" leads to poor decisions. Be specific: explain what the tool does, when it's appropriate, and what it returns.

### Step 2: The AI Analyzes the User Query

When a user asks "What's the weather in Tokyo?", the AI goes through a quick decision process. It understands the intent, recognizes it needs current weather data, identifies the right tool (get_weather), and extracts the parameters (location: Tokyo). Then it formats everything into a structured tool call request.

Here's the interesting part: the AI doesn't actually execute anything. It simply says "I need to call this tool with these parameters." The actual execution happens in your application, which keeps the AI model stateless while giving you full control over security and permissions.

### Step 3: Your Application Executes the Tool

Your application receives the tool call request and does the actual work. This might be calling weather APIs, querying databases, or whatever the tool requires. This separation is actually brilliant: the AI stays stateless while you maintain complete control over security, permissions, and how things get executed.

### Step 4: Return Results to the AI

After executing the tool, you send the results back to the AI. The response might look like:

```json
{
  "temperature": 15,
  "condition": "partly cloudy",
  "humidity": 65
}
```

### Step 5: The AI Generates a Natural Response

Finally, the AI takes the tool results and creates a natural response for the user:

"The current weather in Tokyo is 15Â°C with partly cloudy skies. The humidity is at 65% with light winds. It's a pleasant day for outdoor activities!"

Notice how the AI doesn't just echo raw data back at you. It interprets the results, formats them naturally, and even provides helpful context. That's the magic of combining tool execution with language understanding.

## Building with the Vercel AI SDK

The Vercel AI SDK provides one of the cleanest interfaces for tool calling. Here's how straightforward it can be:

```typescript
import { streamText, tool } from 'ai';
import { z } from 'zod';

const weatherTool = tool({
  description: 'Get current weather for a location',
  parameters: z.object({
    location: z.string(),
    unit: z.enum(['celsius', 'fahrenheit'])
  }),
  execute: async ({ location, unit }) => {
    // Your weather API call here
    return await fetchWeather(location, unit);
  }
});

// Use it in a conversation
const result = await streamText({
  model: openai('gpt-4o'),
  prompt: "What's the weather in Paris?",
  tools: { getWeather: weatherTool }
});
```

The SDK handles all the complexity for you: detecting tool calls, executing them, sending results back to the AI, and managing the conversation flow. You just define what the tool does, and the SDK takes care of the orchestration.

### Working with Multiple Tools

Real applications typically need several tools working together. The beauty is in how the AI coordinates them:

```typescript
const tools = {
  getWeather: tool({ /* ... */ }),
  searchPlaces: tool({ /* ... */ }),
  calculateDistance: tool({ /* ... */ })
};
```

When you ask "Find Italian restaurants in Rome and tell me the weather," the AI automatically calls searchPlaces to find restaurants, then calls getWeather to get conditions, and finally synthesizes everything into a coherent response. No manual orchestration needed. The AI figures out the sequence and dependencies on its own.

## Using OpenRouter for Multi-Model Access

OpenRouter provides a single API for hundreds of models, which makes it incredibly easy to test different providers while keeping your tool definitions consistent. The setup is straightforward. You just point to a different model:

```typescript
// Try Claude
model: 'anthropic/claude-sonnet-4-5'

// Or GPT-4
model: 'openai/gpt-4o'

// Or Gemini
model: 'google/gemini-2.0-flash'
```

All use the same tool calling interface, so switching providers is just changing one line. This makes it easy to compare model performance, latency, and cost for your specific use case.

## Advanced Tool Calling Patterns

### Parallel Tool Execution

Modern LLMs can call multiple tools at the same time. Ask "What's the weather in New York, London, and Tokyo?" and the AI might call get_weather three times simultaneously:

```json
{
  "tool_calls": [
    { "function": { "name": "get_weather", "arguments": "New York" }},
    { "function": { "name": "get_weather", "arguments": "London" }},
    { "function": { "name": "get_weather", "arguments": "Tokyo" }}
  ]
}
```

You can execute these in parallel for faster responses.

### Sequential Tool Chains

Sometimes tools need to run one after another. For "Find restaurants near Times Square and calculate distance from my hotel," the AI has to search for restaurants first, then use those locations to calculate distances, and finally present results with travel times. The AI automatically figures out these dependencies and execution order.

### Conditional Tool Usage

The AI intelligently decides whether tools are even needed:

| User Query | Response Type |
|------------|---------------|
| "What's 2+2?" | Direct answer, no tools |
| "What's the square root of 12345?" | Uses calculator tool |
| "What's the current weather?" | Uses weather API |
| "Explain how weather works" | Direct explanation, no tools |

This natural decision-making creates seamless experiences where tools enhance but don't overwhelm interactions.

## Best Practices for Production

### Write Crystal-Clear Tool Descriptions

The AI relies completely on your descriptions. Here's what makes a difference:

**Bad example**: "Gets some data"

**Good example**: "Retrieves current stock price for a ticker symbol. Use when user asks about stock prices, market values, or recent performance. Returns price in USD, change amount, and percentage change."

The second example tells the AI exactly when to use the tool and what to expect in return. This clarity is everything.

### Handle Errors Gracefully

External APIs fail. Networks timeout. Always plan for failures and return helpful error messages the AI can explain to users:

```typescript
try {
  return await fetchStockPrice(symbol);
} catch (error) {
  return {
    error: "Stock service temporarily unavailable. Please try again in a moment."
  };
}
```

### Provide Rich Context

Don't just return raw numbers. Give the AI context to work with:

```typescript
return {
  temperature: 22,
  condition: "sunny",
  context: "Pleasant spring weather. Perfect for outdoor activities. High UV index, sunscreen recommended."
};
```

This helps the AI provide more insightful, helpful responses.

### Set Reasonable Limits

Prevent runaway processes:

```typescript
await streamText({
  model: openai('gpt-4o'),
  tools,
  maxSteps: 5,      // Maximum 5 tool calls
  maxTokens: 2000   // Limit response length
});
```

## Security Considerations

Tool calling introduces important security considerations:

### Validate All Inputs

Never trust AI-generated parameters without validation. Check formats, sanitize strings, and verify against whitelists before executing tools.

### Use Minimal Permissions

Give tools only the access they need. If a tool queries user profiles, it shouldn't have permission to delete accounts.

### Require Confirmation for Sensitive Actions

For operations like money transfers or data deletion, implement user confirmation steps. The AI can explain what will happen, but humans should approve.

### Implement Rate Limiting

Prevent abuse of expensive operations by limiting how often tools can be called per user or per time period.

## Common Use Cases

### Customer Support Chatbots

Tools for searching knowledge bases, checking order status, and creating support tickets transform basic chatbots into capable support agents that can actually resolve issues.

### Data Analysis Assistants

Tools for querying databases, generating visualizations, and performing calculations enable AI to help with real analytical work, not just conversation.

### Personal Assistants

Tools for calendar access, email, and reminders create AI assistants that can actually manage your schedule and communications.

### Content Creation Agents

Tools for image generation, web search, and document formatting enable AI to create complete content packages, not just text.

## Debugging Tool Calls

When things don't work as expected, here's what to check:

**AI doesn't call tools?** Your description might be unclear. Make it more specific about when to use the tool.

**Wrong tool selected?** Descriptions might be too similar. Make each tool's purpose more distinct.

**Invalid arguments?** Add detailed parameter descriptions so the AI understands what each field needs.

**Too many tool calls?** Set a maxSteps limit to prevent infinite loops.

## The Future of Tool Calling

Tool calling continues to evolve at a rapid pace. Here's what's happening:

**Structured Outputs**: Anthropic's November 2025 launch of structured outputs guarantees that tool arguments match your schemas exactly. No more validation errors from mismatched formats.

**Automatic Context Management**: Claude Sonnet 4.5 now automatically clears old tool results as conversations approach token limits. This means longer, more complex interactions without hitting limits.

**Agentic Workflows**: AI agents that autonomously chain tools to complete complex multi-step tasks are becoming more reliable and capable every month.

**Better Reasoning**: Models are getting smarter at understanding when tools are needed and which combinations solve problems most effectively.

**Native Integrations**: Built-in tools for web search, file operations, and common APIs are becoming standard across providers.

The gap between what AI can understand and what it can do keeps getting smaller.

## Conclusion

Tool calling transforms language models from impressive text generators into practical agents capable of real-world actions. By giving AI access to external functions and APIs, we unlock entirely new categories of applications.

The key principles are straightforward: write clear, specific tool descriptions, handle errors gracefully, provide rich context in results, implement proper security measures, and set reasonable limits.

Whether you're building customer support bots, data analysis tools, or personal assistants, tool calling is the bridge between AI intelligence and practical utility. The frameworks are mature, the APIs are standardized, and the models are increasingly capable.

The future isn't just about AI that talks. It's about AI that acts.

## Further Reading

Want to dive deeper? Here are some helpful resources:

- [Vercel AI SDK Documentation](https://ai-sdk.dev/docs/introduction) - Comprehensive guides and API references
- [Anthropic Tool Use Guide](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview) - Claude-specific patterns and best practices
- [OpenAI Function Calling Guide](https://platform.openai.com/docs/guides/function-calling) - Official OpenAI documentation
- [OpenRouter Documentation](https://openrouter.ai/docs) - Multi-model access patterns
- [AI SDK Tools Registry](https://ai-tools-registry.vercel.app) - Pre-built tools you can use right away